<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Anki Doom Scrolling App</title>
  <style>
    /* Global styles */
    body {
      font-family: Arial, sans-serif;
      background-color: #0d0d0d;
      color: #ffffff;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      overflow-x: hidden;
    }
    h2 {
      color: #00ffcc;
      text-shadow: 0 0 10px #00ffcc;
      text-align: center;
      margin: 20px;
    }
    /* Card container */
    #card-container {
      width: 100%;
      max-width: 600px;
      padding: 0 10px;
      box-sizing: border-box;
    }
    /* Card styles */
    .card {
      background: #1a1a1a;
      padding: 20px;
      margin: 10px 0;
      border-radius: 12px;
      box-shadow: 0 0 15px rgba(0, 255, 204, 0.7);
      overflow-wrap: break-word;
    }
    .front,
    .back {
      font-size: 1.2em;
      margin-bottom: 10px;
    }
    /* Ensure images are responsive */
    img {
      max-width: 100%;
      height: auto;
      display: block;
      margin: 10px auto;
      border-radius: 10px;
      box-shadow: 0 0 10px rgba(0, 255, 204, 0.5);
    }
    /* Cloze deletion styles */
    .cloze {
      color: #00ffcc;
      cursor: pointer;
      font-weight: bold;
      text-shadow: 0 0 10px #00ffcc;
      padding: 2px 4px;
      border: 1px dashed #00ffcc;
      border-radius: 4px;
    }
    .cloze-revealed {
      color: #00ffcc;
      text-shadow: 0 0 10px #00ffcc;
      padding: 2px 4px;
      border: 1px solid #00ffcc;
      border-radius: 4px;
    }
    /* Mobile adjustments */
    @media (max-width: 600px) {
      .front,
      .back {
        font-size: 1em;
      }
    }
  </style>
</head>
<body>
  <h2>Anki Doom Scrolling</h2>
  <div id="card-container"></div>

  <script>
    async function loadDeck() {
      try {
        const response = await fetch('anki_deck.txt');
        const text = await response.text();
        const lines = text.split('\n');

        // Filter out header lines (starting with '#') and empty lines.
        const validLines = lines.filter(line => line && !line.startsWith('#'));

        // Parse each valid line into an object with front and back properties.
        const deckCards = validLines
          .map(line => line.split('\t'))
          .filter(parts => parts.length >= 2)
          .map(parts => ({
            front: parts[0].trim(),
            back: parts[1].trim()
          }));

        // Shuffle the deck cards for randomness and display them.
        displayCards(shuffleArray(deckCards));
      } catch (error) {
        console.error('Error loading deck:', error);
      }
    }

    function displayCards(cards) {
      const container = document.getElementById('card-container');
      cards.forEach(card => {
        const cardElement = document.createElement('div');
        cardElement.className = 'card';
        // Process both front and back for images and cloze deletions.
        const processedFront = processCloze(fixImagePaths(card.front));
        const processedBack = processCloze(fixImagePaths(card.back));
        cardElement.innerHTML = `
          <div class="front">${processedFront}</div>
          <div class="back">${processedBack}</div>
        `;
        container.appendChild(cardElement);
      });
      // Attach event listeners to clickable cloze spans.
      attachClozeListeners();
    }

    // Fix image paths:
    // 1. Remove outer quotes if present.
    // 2. Replace extra quotes in src attributes.
    // 3. Prefix src values with "media/" if not already absolute.
    function fixImagePaths(html) {
      // Remove outer quotes if present (handles both " and ').
      if ((html.startsWith('"') && html.endsWith('"')) || (html.startsWith("'") && html.endsWith("'"))) {
        html = html.slice(1, -1);
      }
      // Replace extra quotes in src attributes.
      html = html.replace(/src=["']{2,}(.*?)["']{2,}/g, 'src="$1"');
      // Prefix src values with "media/" if needed.
      html = html.replace(/<img\s+([^>]*?)src="([^"]+)"([^>]*?)>/g, function(match, pre, src, post) {
        if (!src.startsWith("media/") && !src.startsWith("http") && !src.startsWith("/")) {
          src = "media/" + src;
        }
        return `<img ${pre}src="${src}"${post}>`;
      });
      return html;
    }

    // Process cloze deletions.
    // This function finds all cloze markers (e.g. {{c1::...}}) in the text,
    // then chooses one cloze group (like "c1", "c2", etc.) at random to hide,
    // while revealing the others.
    function processCloze(html) {
      const regex = /\{\{c(\d+)::(.*?)\}\}/g;
      const matches = [...html.matchAll(regex)];
      if (matches.length === 0) {
        return html;
      }
      // Collect the cloze group numbers found in this card.
      const groups = new Set();
      matches.forEach(match => groups.add(match[1]));
      const groupsArr = Array.from(groups);
      // Randomly select one group to hide.
      const hiddenGroup = groupsArr[Math.floor(Math.random() * groupsArr.length)];

      // Replace each cloze deletion.
      return html.replace(regex, (match, clozeNumber, content) => {
        let parts = content.split('::');
        let answer = parts[0].trim();
        let hint = parts.length > 1 ? parts[1].trim() : '...';
        if (clozeNumber === hiddenGroup) {
          // Hidden group: show clickable span with hint.
          return '<span class="cloze" data-answer=' + JSON.stringify(answer) + '>[' + hint + ']</span>';
        } else {
          // Other groups: show the answer immediately.
          return '<span class="cloze-revealed">' + answer + '</span>';
        }
      });
    }

    // Attach event listeners to all clickable cloze spans.
    function attachClozeListeners() {
      const clozeSpans = document.querySelectorAll('.cloze');
      clozeSpans.forEach(span => {
        span.addEventListener('click', function() {
          this.innerHTML = this.dataset.answer;
          this.className = 'cloze-revealed';
        });
      });
    }

    // Simple Fisherâ€“Yates shuffle.
    function shuffleArray(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
      return array;
    }

    document.addEventListener('DOMContentLoaded', loadDeck);
  </script>
</body>
</html>