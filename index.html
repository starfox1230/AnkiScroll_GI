<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Anki Doom Scrolling App</title>
  <style>
    /* Global styles */
    body {
      font-family: Arial, sans-serif;
      background-color: #0d0d0d;
      color: #ffffff;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      overflow-x: hidden;
    }
    h2 {
      color: #00ffcc;
      text-shadow: 0 0 10px #00ffcc;
      text-align: center;
      margin: 20px;
    }
    /* Card container */
    #card-container {
      width: 100%;
      max-width: 600px;
      padding: 0 10px;
      box-sizing: border-box;
    }
    /* Card styles – increased vertical margin for more spacing.
       The box shadow is set dynamically and we also set a CSS variable for the card's neon highlight. */
    .card {
      background: #1a1a1a;
      padding: 20px;
      margin: 20px 0;
      border-radius: 12px;
      overflow-wrap: break-word;
    }
    .front,
    .back {
      font-size: 1.2em;
      margin-bottom: 10px;
    }
    /* Responsive images using the card's neon color via CSS variable */
    img {
      max-width: 100%;
      height: auto;
      display: block;
      margin: 10px auto;
      border-radius: 10px;
      box-shadow: 0 0 10px var(--card-highlight);
    }
    /* Hidden cloze deletions: clickable, bright red */
    .cloze-hidden {
      color: #FF5555;
      cursor: pointer;
      font-weight: bold;
      text-shadow: 0 0 10px #FF5555;
      padding: 2px 4px;
      border: 1px dashed #FF5555;
      border-radius: 4px;
    }
    /* Revealed cloze (clicked hidden cloze turns green) */
    .cloze-revealed {
      color: #00ffcc;
      text-shadow: 0 0 10px #00ffcc;
      padding: 2px 4px;
      border: 1px solid #00ffcc;
      border-radius: 4px;
    }
    /* Automatically revealed cloze deletions (from non-hidden groups)
       get their inline style from the card’s neon color. */
    .cloze-random {
      /* Styles are applied inline in the HTML based on the card's neon color. */
    }
    /* Mobile adjustments */
    @media (max-width: 600px) {
      .front,
      .back {
        font-size: 1em;
      }
    }
  </style>
</head>
<body>
  <h2>Anki Doom Scrolling</h2>
  <div id="card-container"></div>

  <script>
    // Array of neon colors for the card theme (for non-hidden cloze items and box shadow)
    const neonColors = [
      "#39FF14", // neon green
      "#0FF0FC", // neon cyan
      "#FF6EC7", // neon pink
      "#CCFF00", // neon lime
      "#FF1493", // deep pink
      "#FFD700", // gold
      "#FF00FF"  // magenta
    ];

    const REVEALED_CLOZE_COLOR = "#00ffcc"; // constant green for revealed cloze (after click)
    const HIDDEN_CLOZE_INITIAL_COLOR = "#FF5555"; // bright red for hidden cloze (before click)

    async function loadDeck() {
      try {
        const response = await fetch('anki_deck.txt');
        const text = await response.text();
        const lines = text.split('\n');

        // Filter out header lines (starting with '#') and empty lines.
        const validLines = lines.filter(line => line && !line.startsWith('#'));

        // Parse each valid line into an object with front and back properties.
        const deckCards = validLines
          .map(line => line.split('\t'))
          .filter(parts => parts.length >= 2)
          .map(parts => ({
            front: parts[0].trim(),
            back: parts[1].trim()
          }));

        // Shuffle and display the deck cards.
        displayCards(shuffleArray(deckCards));
      } catch (error) {
        console.error('Error loading deck:', error);
      }
    }

    function displayCards(cards) {
      const container = document.getElementById('card-container');
      cards.forEach(card => {
        const cardElement = document.createElement('div');
        cardElement.className = 'card';

        // Pick a random neon color for this card.
        const cardColor = neonColors[Math.floor(Math.random() * neonColors.length)];
        // Set the card's box shadow and CSS variable for highlight.
        cardElement.style.boxShadow = "0 0 15px " + cardColor;
        cardElement.style.setProperty('--card-highlight', cardColor);

        // Process cloze deletions on both front and back, passing the cardColor.
        const processedFront = processCloze(fixImagePaths(card.front), cardColor);
        const processedBack = processCloze(fixImagePaths(card.back), cardColor);
        cardElement.innerHTML = `
          <div class="front">${processedFront}</div>
          <div class="back">${processedBack}</div>
        `;
        container.appendChild(cardElement);
      });
      // Attach event listeners to clickable (hidden) cloze spans.
      attachClozeListeners();
    }

    // fixImagePaths:
    // 1. Remove outer quotes if present.
    // 2. Fix extra quotes in src attributes.
    // 3. Prefix src values with "media/" if needed.
    function fixImagePaths(html) {
      // Remove outer quotes if present.
      if ((html.startsWith('"') && html.endsWith('"')) || (html.startsWith("'") && html.endsWith("'"))) {
        html = html.slice(1, -1);
      }
      // Replace extra quotes in src attributes.
      html = html.replace(/src=["']{2,}(.*?)["']{2,}/g, 'src="$1"');
      // Prefix src values with "media/" if needed.
      html = html.replace(/<img\s+([^>]*?)src="([^"]+)"([^>]*?)>/g, function(match, pre, src, post) {
        if (!src.startsWith("media/") && !src.startsWith("http") && !src.startsWith("/")) {
          src = "media/" + src;
        }
        return `<img ${pre}src="${src}"${post}>`;
      });
      return html;
    }

    // processCloze:
    // Accepts the card's HTML and the cardColor.
    // Randomly chooses one cloze group to hide (clickable, styled in bright red),
    // while rendering the other cloze deletions immediately using the cardColor.
    function processCloze(html, cardColor) {
      const regex = /\{\{c(\d+)::(.*?)\}\}/g;
      const matches = [...html.matchAll(regex)];
      if (matches.length === 0) return html;

      // Collect all cloze group numbers in this card.
      const groups = new Set();
      matches.forEach(match => groups.add(match[1]));
      const groupsArr = Array.from(groups);
      // Randomly select one group to hide.
      const hiddenGroup = groupsArr[Math.floor(Math.random() * groupsArr.length)];

      // Replace each cloze deletion.
      return html.replace(regex, (match, clozeNumber, content) => {
        let parts = content.split('::');
        let answer = parts[0].trim();
        let hint = parts.length > 1 ? parts[1].trim() : '...';
        if (clozeNumber === hiddenGroup) {
          // Hidden group: output clickable span in bright red.
          return '<span class="cloze-hidden" data-answer=' + JSON.stringify(answer) + '>[' + hint + ']</span>';
        } else {
          // Other groups: output immediately revealed span styled with the cardColor.
          return '<span class="cloze-random" style="color: ' + cardColor + '; text-shadow: 0 0 10px ' + cardColor + '; border: 1px solid ' + cardColor + '; padding: 2px 4px; border-radius: 4px;">' + answer + '</span>';
        }
      });
    }

    // Attach event listeners to all clickable (hidden) cloze spans.
    function attachClozeListeners() {
      const clozeSpans = document.querySelectorAll('.cloze-hidden');
      clozeSpans.forEach(span => {
        span.addEventListener('click', function() {
          // When clicked, replace the hint with the answer and change its styling.
          this.innerHTML = this.dataset.answer;
          this.classList.remove("cloze-hidden");
          this.classList.add("cloze-revealed");
        });
      });
    }

    // Simple Fisher–Yates shuffle.
    function shuffleArray(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
      return array;
    }

    document.addEventListener('DOMContentLoaded', loadDeck);
  </script>
</body>
</html>